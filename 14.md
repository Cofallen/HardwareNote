## 调车任务

- [ ] 引入变参pid，多种
- [x] VOFA debug

## 软件学习

### SoftTarget

- [x] github action
- [x] 归并排序复习

### SoftNote

#### github
github [action](https://github.com/features/actions) 可以通过 .github/workflow/xx.yaml 完成自动化运行，可以认为是虚拟机。

有个好[教程](https://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html)，可以用来配合学习网页搭建。

#### c 分配空间

##### 使用结构体

```c
#include <stdio.h>
#include <stdlib.h>

struct Data {
    float *floatArray;
    char *charArray;
};

int main() {
    int n = 5;  // 假设有5个浮点数和4个字符

    struct Data *data = (struct Data *)calloc(1, sizeof(struct Data));
    data->floatArray = (float *)calloc(n, sizeof(float));
    data->charArray = (char *)calloc(4, sizeof(char));

    // 现在你可以访问和操作data结构中的浮点数和字符数组了

    // 释放内存
    free(data->floatArray);
    free(data->charArray);
    free(data);

    return 0;
}
```

##### 拼接不同类型空间

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int n1 = 3;
    int n2 = 4;

    // 分配第一个数组（整数数组）
    int *intArray = (int *)calloc(n1, sizeof(int));
    for (int i = 0; i < n1; i++) {
        intArray[i] = i + 1;
    }

    // 分配第二个数组（浮点数数组）
    float *floatArray = (float *)calloc(n2, sizeof(float));
    for (int i = 0; i < n2; i++) {
        floatArray[i] = i + 0.5;
    }

    // 创建一个新的数组，将intArray和floatArray拼接起来
    int totalSize = n1 + n2;
    void *combinedArray = malloc((n1 * sizeof(int)) + (n2 * sizeof(float)));

    // 将intArray和floatArray的内容拷贝到combinedArray
    memcpy(combinedArray, intArray, n1 * sizeof(int));
    memcpy((char *)combinedArray + n1 * sizeof(int), floatArray, n2 * sizeof(float));

    // 现在combinedArray包含了intArray和floatArray的元素

    // 释放内存
    free(intArray);
    free(floatArray);
    free(combinedArray);

    return 0;
}
```

##### 动态创建二维数组

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int rows = 3;
    int cols = 4;

    // 分配二维数组
    int **array2D = (int **)calloc(rows, sizeof(int *));
    for (int i = 0; i < rows; i++) {
        array2D[i] = (int *)calloc(cols, sizeof(int));
    }

    // 现在你可以使用array2D作为一个3x4的二维数组来存储和访问数据

    // 释放内存
    for (int i = 0; i < rows; i++) {
        free(array2D[i]);
    }
    free(array2D);

    return 0;
}
```

##### 动态字符串

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char *str = (char *)malloc(6 * sizeof(char));  // 分配初始内存空间
    strcpy(str, "Hello");

    // 扩展字符串
    str = (char *)realloc(str, 11 * sizeof(char));  // 重新分配内存
    strcat(str, " World");

    printf("%s\n", str);  // 输出 "Hello World"

    // 释放内存
    free(str);

    return 0;
}
```

## 硬件学习

### HardTarget

- [ ] 一节视频
- [x] 熟悉基本元件性质
- [ ] 一节寄存器

### HardNote

1. [Register option for keil](https://www.keil.com/support/man/docs/uv4cl/uv4cl_db_dbg_cpuregs.htm)

#### Some details by AI

在 STM32 微控制器中，CAN (Controller Area Network) 外设的 ESR (Error Status Register) 寄存器用于报告 CAN 控制器的错误状态。ESR 寄存器包含多个字段，每个字段表示不同的错误状态或信息。

以下是 ESR 寄存器的详细说明：

##### ESR 寄存器结构

ESR 寄存器通常是 32 位的，具体字段如下：

- **EWGF (Error Warning Flag)**: 位 0
  - 0: 错误计数器小于 96
  - 1: 错误计数器大于或等于 96

- **EPVF (Error Passive Flag)**: 位 1
  - 0: CAN 控制器处于错误主动状态
  - 1: CAN 控制器处于错误被动状态

- **BOFF (Bus-Off Flag)**: 位 2
  - 0: CAN 控制器未处于总线关闭状态
  - 1: CAN 控制器处于总线关闭状态

- **LEC (Last Error Code)**: 位 4-6
  - 000: No Error
  - 001: Stuff Error
  - 010: Form Error
  - 011: Acknowledgment Error
  - 100: Bit recessive Error
  - 101: Bit dominant Error
  - 110: CRC Error
  - 111: Set by software

- **TEC (Transmit Error Counter)**: 位 16-23
  - 8 位的传输错误计数器

- **REC (Receive Error Counter)**: 位 24-31
  - 8 位的接收错误计数器

### 读取 ESR 寄存器

在代码中，你可以通过访问 CAN 外设的 ESR 寄存器来读取这些状态。以下是一个示例代码，展示如何读取和解释 ESR 寄存器的值：

```c
#include "stm32f4xx.h"  // 根据你的具体型号选择合适的头文件

void check_CAN_error_status(void) {
    uint32_t esr = CAN1->ESR;  // 假设使用 CAN1

    // 读取各个标志位
    uint8_t ewgf = (esr & CAN_ESR_EWGF) >> 0;
    uint8_t epvf = (esr & CAN_ESR_EPVF) >> 1;
    uint8_t boff = (esr & CAN_ESR_BOFF) >> 2;
    uint8_t lec = (esr & CAN_ESR_LEC_Msk) >> 4;
    uint8_t tec = (esr & CAN_ESR_TEC_Msk) >> 16;
    uint8_t rec = (esr & CAN_ESR_REC_Msk) >> 24;

    // 打印或处理错误状态
    if (ewgf) {
        // 错误警告标志被置位
    }
    if (epvf) {
        // 错误被动标志被置位
    }
    if (boff) {
        // 总线关闭标志被置位
    }

    // 处理最后一个错误代码
    switch (lec) {
        case 0x00:
            // No Error
            break;
        case 0x01:
            // Stuff Error
            break;
        case 0x02:
            // Form Error
            break;
        case 0x03:
            // Acknowledgment Error
            break;
        case 0x04:
            // Bit recessive Error
            break;
        case 0x05:
            // Bit dominant Error
            break;
        case 0x06:
            // CRC Error
            break;
        case 0x07:
            // Set by software
            break;
    }

    // 处理传输和接收错误计数器
    // tec 和 rec 的值可以用于进一步的错误处理
}
```

通过读取和解释 ESR 寄存器的值，你可以监控和处理 CAN 总线上的错误状态。
